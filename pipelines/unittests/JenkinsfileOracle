pipeline {

    environment {
        // gradle.properties variables
        CONTEXT_NAME        = 'etendo'
        BBDD_SID            = 'orclsid'
        BBDD_PORT           = '1521'
        BBDD_SYSTEMUSER     = 'sys AS SYSDBA'
        BBDD_SYSTEMPASS     = 'oraclepassword'
        BBDD_USER           = 'C##TAD'
        BBDD_PASSWORD       = 'tad'
        NEXUS_USER          = credentials('nexus-admin-user')
        NEXUS_PASSWORD      = credentials('nexus-admin-passwd')
        GITHUB_USER         = 'etendobot'
        GITHUB_TOKEN        = credentials('github-read-package-token')
        TZ                  = 'UTC'
        LANG                = 'en_US.UTF-8'
        EMAIL_ADDRESS       = credentials('email_builds')

        REPO_NAME           = 'etendo_core'
        REPO_URL            = 'https://github.com/etendosoftware/etendo_core'

        PLUGIN_NAME         = 'buildSrc'
        PLUGIN_URL          = 'git@github.com:etendosoftware/com.etendoerp.gradleplugin.git'

        SUCCESS             = 'SUCCESS'
        FAILED              = 'FAILED'
        UNSTABLE            = 'UNSTABLE'
        ABORTED             = 'ABORTED'

        ORCL_VERSION        = '19c'

        CONTEXT_BUILD       = 'Unit Tests with Oracle Database'
        ACCESS_TOKEN        = credentials('access_token_github')

        COMMIT_INPROGRESS_STATUS = 'pending'
        COMMIT_SUCCESS_STATUS    = 'success'
        COMMIT_FAILED_STATUS     = 'failure'

        TRUE  = 'true'
        FALSE = 'false'

        // Jenkins credential stored as base64-encoded string for another Atlassian user, not etendobot
        JIRA_ACCESS_TOKEN         = credentials('jira-access-token')
        // Removed when 26.1 will release
        PRERELEASE_BRANCH = 'prerelease/27.1'
    }

    agent {
        kubernetes {
            inheritFrom 'jenkins-node-unittests-orcl'
            defaultContainer 'jnlp'
            yamlFile 'pipelines/unittests/AgentOracle.yaml'
        }
    }

    stages {
        stage('Check Pipeline Skip Condition') { // MARK: Check Pipeline Skip Condition
            steps {
                script {
                    try {
                        echo "---------------------- Setting up Environment Variables ----------------------"
                        env.STATUS_TEST = SUCCESS // Variable to track the status of the test execution.
                        env.STATUS_BUILD = FAILED // Variable to track the status of the build.
                        env.FAILED_SUITES = "" // List to collect failed test suites
                        sh 'printenv'

                        echo "--------------- Checking if pipeline should be skipped ---------------"
                        def changedFiles = sh(
                        script: "git diff --name-only HEAD~1 HEAD",
                        returnStdout: true
                        ).trim()

                        echo "Files changed in last commit: ${changedFiles}"

                        // Check if only Jenkinsfile and/or sonarUtils.groovy were changed
                        def filesList = changedFiles.split('\n')
                        def allowedFiles = [
                            "pipelines/unittests/Jenkinsfile",
                            "pipelines/unittests/utils/sonarUtils.groovy"
                        ]

                        // Check if all changed files are in the allowed list
                        def onlyAllowedFiles = filesList.every { file -> 
                            allowedFiles.contains(file)
                        }

                        // Additionally check that at least one of the allowed files was changed
                        def hasAllowedFiles = filesList.any { file -> 
                            allowedFiles.contains(file)
                        }

                        if (onlyAllowedFiles && hasAllowedFiles) {
                            echo "‚è≠Ô∏è Only Jenkinsfile and/or sonarUtils.groovy were changed. Skipping pipeline execution."
                            echo "üìã Changed files: ${changedFiles}"

                            sh "./pipelines/unittests/build-update.sh ${REPO_NAME} ${COMMIT_SUCCESS_STATUS} \"Pipeline skipped - Only pipeline config files changed\" ${ACCESS_TOKEN} ${GIT_COMMIT} ${BUILD_URL} \"${CONTEXT_BUILD}\""

                            echo "‚úÖ Pipeline execution aborted successfully. Commit marked as success."
                            currentBuild.result = ABORTED
                            return
                        } else {
                            echo "‚úÖ Pipeline will continue - Changes detected in other files."
                            echo "üìã Changed files: ${changedFiles}"
                            currentBuild.result = SUCCESS
                        }
                    } catch (Exception e) {
                        echo "‚ùå Error in pipeline skip condition check: ${e.getMessage()}"            
                        env.ERROR_MESSAGE = "Pipeline Check Failed"
                        sh "./pipelines/unittests/build-update.sh ${REPO_NAME} ${COMMIT_FAILED_STATUS} \"${env.ERROR_MESSAGE}\" ${ACCESS_TOKEN} ${GIT_COMMIT} ${BUILD_URL} \"${CONTEXT_BUILD}\""
                        currentBuild.result = FAILED
                        error("Failed to check pipeline skip condition: ${e.getMessage()}")
                    }
                }
            }
        }
        stage ('Stack Configuration') { // MARK: Stack Configuration
            when {
                expression {
                    currentBuild.result == SUCCESS
                }
            }
            steps {
                container('compiler') {
                    script {
                        try {
                            echo "--------------- Getting Backport Branch Information ---------------"
                            def pattern = /.*-Y\d{2}$/
                            def matches = (env.GIT_BRANCH ==~ pattern)
                            env.CONTAINS_Y_SUFFIX = matches ? TRUE : FALSE
                            echo "[DEBUG]: CONTAINS_Y_SUFFIX set to: ${env.CONTAINS_Y_SUFFIX}"
                            env.FROM_BACKPORT = FALSE
                            env.FROM_PRERELEASE = FALSE
                            def yearBackportBranch = (env.BACKPORT_BRANCH =~ /release\/(\d{2})\./)?.find() ? (env.BACKPORT_BRANCH =~ /release\/(\d{2})\./)[0][1] : null
                            def yearPrereleaseBranch = (env.PRERELEASE_BRANCH =~ /prerelease\/(\d{2})\./)?.find() ? (env.PRERELEASE_BRANCH =~ /prerelease\/(\d{2})\./)[0][1] : null
                            echo "[DEBUG]: yearBackportBranch: ${yearBackportBranch}"
                            echo "[DEBUG]: yearPrereleaseBranch: ${yearPrereleaseBranch}"
                            
                            // Extract backport branch information without using Matcher object
                            if (env.CONTAINS_Y_SUFFIX == TRUE) {
                                def yearCommitBranch = (env.GIT_BRANCH =~ /-Y(\d{2})/)?.find() ? (env.GIT_BRANCH =~ /-Y(\d{2})/)[0][1] : null
                                echo "[DEBUG]: yearCommitBranch: ${yearCommitBranch}"
                                if (yearCommitBranch) {
                                    if (yearBackportBranch && yearCommitBranch == yearBackportBranch) {
                                        env.FROM_BACKPORT = env.TRUE
                                        echo "[DEBUG]: Setting FROM_BACKPORT = TRUE (year match: ${yearCommitBranch})"
                                    } else if (yearPrereleaseBranch && yearCommitBranch == yearPrereleaseBranch) {
                                        env.FROM_PRERELEASE = env.TRUE
                                        echo "[DEBUG]: Setting FROM_PRERELEASE = TRUE (year match: ${yearCommitBranch})"
                                    }
                                }
                            } else if (GIT_BRANCH.startsWith("release")) {
                                echo '-------------------------- Backport Branch Detected --------------------------'
                                env.FROM_BACKPORT = env.TRUE
                            } else if (GIT_BRANCH.startsWith("prerelease")) {
                                echo '-------------------------- Prerelease Branch Detected --------------------------'
                                env.FROM_PRERELEASE = env.TRUE
                            }
                            echo "---------------- Stack Configuration ----------------"
                            def rootDir = pwd()
                            def stackConfig = load "${rootDir}/pipelines/unittests/utils/stackConfig.groovy"

                            def stackConfiguration = stackConfig.resolveStackConfiguration(env.FROM_BACKPORT, env.FROM_PRERELEASE)

                            env.JAVA_HOME = "/usr/lib/jvm/jdk-17.0.13"
                            env.TOMCAT_URL = "https://dlcdn.apache.org/tomcat/tomcat-11/v11.0.15/bin/apache-tomcat-11.0.15.tar.gz"
                            env.STACK_TYPE = "PRERELEASE 27Q1"

                            echo "Stack Type: ${env.STACK_TYPE}"
                            echo "Tomcat URL: ${env.TOMCAT_URL}"
                            echo "Java Home: ${env.JAVA_HOME}"

                            sh "wget -O apache-tomcat.tar.gz ${TOMCAT_URL}"
                            sh "tar -xvf apache-tomcat.tar.gz -C ${WORKSPACE}"

                            env.TOMCAT_FOLDER = stackConfig.getTomcatFolder()
                            env.CATALINA_HOME = "${WORKSPACE}/${TOMCAT_FOLDER}"
                            env.CATALINA_BASE = "${WORKSPACE}/${TOMCAT_FOLDER}"

                            env.STACK_INFO = stackConfig.generateStackMessage()
                            echo "__________________________________________________"
                            echo "${env.STACK_INFO}"
                            echo "__________________________________________________"
                        } catch (Exception e) {
                            env.ERROR_MESSAGE = "Stack Configuration Failed"
                            echo "--------------- ${env.ERROR_MESSAGE} ---------------"
                            echo "Exception occurred: " + e.toString()
                            currentBuild.result = FAILED
                            error(env.ERROR_MESSAGE)
                        }
                    }
                }
            }
        }
        stage('Build Environment') { // MARK: Build Environment
            when {
                expression {
                    currentBuild.result == SUCCESS
                }
            }
            steps {
                container('compiler') {
                    script {
                        try {
                            sh "./pipelines/unittests/build-update.sh ${REPO_NAME} ${COMMIT_INPROGRESS_STATUS} \"Starting Build Environment\" ${ACCESS_TOKEN} ${GIT_COMMIT} ${BUILD_URL} \"${CONTEXT_BUILD}\""

                            sh "git clone ${REPO_URL} ${REPO_NAME}"

                            env.WORKDIR_ETENDO = "${pwd()}"

                            dir(REPO_NAME) {
                                echo "---------------- Getting Commit Information ----------------"
                                sh "git checkout ${GIT_COMMIT}"

                                echo "--------------- Configure gradle.properties in Etendo ---------------"
                                sh """
                                echo "\n
                                context.name=${CONTEXT_NAME}\n
                                bbdd.rdbms=ORACLE\n
                                bbdd.driver=oracle.jdbc.driver.OracleDriver\n
                                bbdd.url=jdbc:oracle:thin:@localhost:${BBDD_PORT}:${BBDD_SID}?oracle.net.disableOob=true\n
                                bbdd.sid=${BBDD_SID}\n
                                bbdd.systemUser=${BBDD_SYSTEMUSER}\n
                                bbdd.systemPassword=${BBDD_SYSTEMPASS}\n
                                bbdd.user=${BBDD_USER}\n
                                bbdd.password=${BBDD_PASSWORD}\n
                                bbdd.sessionConfig=ALTER SESSION SET NLS_DATE_FORMAT='DD-MM-YYYY' NLS_NUMERIC_CHARACTERS='.,'\n

                                nexusUser=${NEXUS_USER}\n
                                nexusPassword=${NEXUS_PASSWORD}\n
                                githubUser=${GITHUB_USER}\n
                                githubToken=${GITHUB_TOKEN}\n
                                allow.root=true\n
                                org.gradle.jvmargs=-Dfile.encoding=UTF-8\n
                                org.gradle.daemon=false" > gradle.properties
                                """

                                sh """
                                mkdir -p build/lib/runtime
                                ./gradlew prepareConfig --info
                                ./gradlew setup --info
                                ./gradlew expandModules --info
                                """

                                sh "./pipelines/unittests/build-update.sh ${REPO_NAME} ${COMMIT_INPROGRESS_STATUS} \"Configuring Stack\" ${ACCESS_TOKEN} ${GIT_COMMIT} ${BUILD_URL} \"${CONTEXT_BUILD}\""
                                echo "--------------- Waiting for Oracle DB to be ready ---------------"
                                sleep( time: 20, unit: 'MINUTES' ) // Temporary sleep to allow DB to be fully started

                                sh """
                                ./gradlew install --info
                                ./gradlew smartbuild --info
                                """
                            }
                            sh "${WORKSPACE}/${TOMCAT_FOLDER}/bin/catalina.sh start"
                            sleep( time: 1, unit: 'MINUTES' ) // Wait additional 2 minutes to ensure Tomcat is fully started
                            echo 'Build of Etendo Core Finished'
                            currentBuild.result = SUCCESS
                            env.STATUS_BUILD = SUCCESS
                        } catch (Exception e) {
                            env.ERROR_MESSAGE = 'Build Environment Failed'
                            echo "Exception occurred: " + e.toString()
                            currentBuild.result = FAILED
                            error(env.ERROR_MESSAGE)
                            env.STATUS_BUILD = FAILED
                        }
                    }
                }
            }
        }
//___________________________________________________________________________________________
// ------------------------------ WEB SERVICES TESTS ----------------------------------------
        stage ('Web Service Test Suite'){ // MARK: Web Service Test Suite
            when {
                expression {
                    env.STATUS_BUILD == SUCCESS
                }
            }
            steps {
                container('compiler') {
                    script {
                        dir(REPO_NAME) {
                            def suiteName = "org.openbravo.test.WebserviceTestSuite"
                            try {
                                sh "./pipelines/unittests/build-update.sh ${REPO_NAME} ${COMMIT_INPROGRESS_STATUS} \"Running Test Suites\" ${ACCESS_TOKEN} ${GIT_COMMIT} ${BUILD_URL} \"${CONTEXT_BUILD}\""
                                echo "--------------- Running ${suiteName} ---------------"
                                sh "./gradlew test --tests ${suiteName} --info"
                            } catch (Exception e) {
                                env.ERROR_MESSAGE = "${suiteName} Failed"
                                echo "--------------- ${env.ERROR_MESSAGE} ---------------"
                                echo 'Exception occurred: ' + e.toString()
                                currentBuild.result = UNSTABLE
                                unstable(env.ERROR_MESSAGE)
                                env.STATUS_TEST = FAILED
                                
                                def currentFailed = env.FAILED_SUITES ?: ""
                                env.FAILED_SUITES = currentFailed.isEmpty() ? "${suiteName}" : "${currentFailed}, ${suiteName}"
                            } finally {
                                if (fileExists('build/reports/tests/test/')) {
                                    publishHTML([
                                        allowMissing: true,
                                        alwaysLinkToLastBuild: false,
                                        keepAll: true,
                                        reportDir: 'build/reports/tests/test',
                                        reportFiles: '*.html',
                                        reportName: 'WEBSERVICES TESTS REPORT',
                                        reportTitles: ''
                                    ])
                                    sh "rm -rf build/reports/tests/test"
                                } else {
                                    echo "Report directory of Webservices tests does not exist. Skipping HTML report publishing."
                                }
                                sh "${WORKSPACE}/${TOMCAT_FOLDER}/bin/catalina.sh stop"
                                sh './gradlew --stop'
                            }
                        }
                    }
                }
            }
        }
// __________________________________________________________________________________________
// ------------------------------ com.smf.* TESTS ------------------------------------------
        stage ('Core Test Suite') { // MARK: com.smf.* Test Suite
            when {
                expression {
                    env.STATUS_BUILD == SUCCESS
                }
            }
            steps {
                container('compiler') {
                    script {
                        dir(REPO_NAME) {
                            def suiteName = "com.smf.test.CoreTestSuite"
                            try {
                                echo "--------------- Running ${suiteName} ---------------"
                                sh "./gradlew test --tests ${suiteName} --info"
                                echo "--------------- ${suiteName} Successful ---------------"
                            } catch (Exception e) {
                                env.ERROR_MESSAGE = "${suiteName} Failed"
                                echo "--------------- ${env.ERROR_MESSAGE} ---------------"
                                echo 'Exception occurred: ' + e.toString()
                                currentBuild.result = UNSTABLE
                                unstable(env.ERROR_MESSAGE)
                                env.STATUS_TEST = FAILED
                                
                                def currentFailed = env.FAILED_SUITES ?: ""
                                env.FAILED_SUITES = currentFailed.isEmpty() ? "${suiteName}" : "${currentFailed}, ${suiteName}"
                            } finally {
                                if (fileExists("build/reports/tests/test/")) {
                                    publishHTML([
                                        allowMissing: true,
                                        alwaysLinkToLastBuild: false,
                                        keepAll: true,
                                        reportDir: 'build/reports/tests/test',
                                        reportFiles: '*.html',
                                        reportName: 'com.smf.* TESTS REPORT',
                                        reportTitles: ''
                                    ])
                                    sh "rm -rf build/reports/tests/test"
                                } else {
                                    echo "Report directory of com.smf.* tests does not exist. Skipping HTML report publishing."
                                }
                            }
                        }
                    }
                }
            }
        }
//___________________________________________________________________________________________
// ------------------------------- STANDALONE TESTS -----------------------------------------
        stage ('Standalone Test Suite') { // MARK: Standalone Test Suite
            when {
                expression {
                    env.STATUS_BUILD == SUCCESS
                }
            }
            steps {
                container('compiler') {
                    script {
                        dir(REPO_NAME) {
                            def suiteName = "org.openbravo.test.StandaloneTestSuite"
                            try {
                                echo "--------------- Running ${suiteName} ---------------"
                                sh "./gradlew test --tests \"${suiteName}\" --info"
                            } catch (Exception e) {
                                env.ERROR_MESSAGE = "${suiteName} Failed"
                                echo "--------------- ${env.ERROR_MESSAGE} ---------------"
                                echo 'Exception occurred: ' + e.toString()
                                currentBuild.result = UNSTABLE
                                unstable(env.ERROR_MESSAGE)
                                env.STATUS_TEST = FAILED
                                
                                def currentFailed = env.FAILED_SUITES ?: ""
                                env.FAILED_SUITES = currentFailed.isEmpty() ? "${suiteName}" : "${currentFailed}, ${suiteName}"
                            }  finally {
                                if (fileExists('build/reports/tests/test/')) {
                                    publishHTML([
                                        allowMissing: true,
                                        alwaysLinkToLastBuild: false,
                                        keepAll: true,
                                        reportDir: 'build/reports/tests/test',
                                        reportFiles: '*.html',
                                        reportName: 'STANDALONE TESTS REPORT',
                                        reportTitles: ''
                                    ])
                                    sh "rm -rf build/reports/tests/test"
                                } else {
                                    echo "Report directory of Standalone tests does not exist. Skipping HTML report publishing."
                                }
                            }
                        }
                    }
                }
            }
        }
//___________________________________________________________________________________________
// ----------------------------------- com.etendoerp.* TESTS -------------------------------------------
        stage ('com.etendoerp.* Tests') { // MARK: com.etendoerp.* Tests
            when {
                expression {
                    env.STATUS_BUILD == SUCCESS
                }
            }
            steps {
                container('compiler') {
                    script {
                        dir(REPO_NAME) {
                            def suiteName = "com.etendoerp.*"
                            try {
                                echo "--------------- Running ${suiteName} ---------------"
                                sh "./gradlew test --tests \"${suiteName}\" --info"
                            } catch (Exception e) {
                                env.ERROR_MESSAGE = "${suiteName} Tests Failed"
                                echo "--------------- ${env.ERROR_MESSAGE} ---------------"
                                echo 'Exception occurred: ' + e.toString()
                                currentBuild.result = UNSTABLE
                                unstable(env.ERROR_MESSAGE)
                                env.STATUS_TEST = FAILED
                                
                                def currentFailed = env.FAILED_SUITES ?: ""
                                env.FAILED_SUITES = currentFailed.isEmpty() ? "${suiteName} Tests" : "${currentFailed}, ${suiteName} Tests"
                            }  finally {
                                if (fileExists('build/spock-reports/')) {
                                    publishHTML([
                                        allowMissing: true,
                                        alwaysLinkToLastBuild: false,
                                        keepAll: true,
                                        reportDir: 'build/spock-reports/',
                                        reportFiles: '*.html',
                                        reportName: 'com.etendoerp.* SPOCK TESTS REPORT',
                                        reportTitles: ''
                                    ])
                                    sh "rm -rf build/spock-reports"
                                } else {
                                    echo "Spock report directory of com.etendoerp.* tests does not exist. Skipping HTML report publishing."
                                }

                                if (fileExists('build/reports/tests/test/')) {
                                    publishHTML([
                                        allowMissing: true,
                                        alwaysLinkToLastBuild: false,
                                        keepAll: true,
                                        reportDir: 'build/reports/tests/test',
                                        reportFiles: '*.html',
                                        reportName: 'com.etendoerp.* TESTS REPORT',
                                        reportTitles: ''
                                    ])
                                    sh "rm -rf build/reports/tests/test"
                                } else {
                                    echo "Report directory of com.etendoerp.* does not exist. Skipping HTML report publishing."
                                }

                            }
                        }
                    }
                }
            }
        }
    }
    post { // MARK: Post
        always {
            container('compiler') {
                script {
                    echo "---------------- Getting Commit & Stack Information ----------------"
                    def rootDir2 = pwd()
                    sh "git config --global --add safe.directory ${rootDir2}"
                    def infoCommit = load "${rootDir2}/pipelines/unittests/utils/infoCommit.groovy"
                    def stackConfig = load "${rootDir2}/pipelines/unittests/utils/stackConfig.groovy"
                    env.COMMIT_INFO = infoCommit.generateCommitInfo(env.REPO_URL)
                    env.STACK_INFO = stackConfig.generateStackMessage()
                }
            }
        }
        success {
            script {
                sh "./pipelines/unittests/build-update.sh ${REPO_NAME} ${COMMIT_SUCCESS_STATUS} \"Successful Test Suites\" ${ACCESS_TOKEN} ${GIT_COMMIT} ${BUILD_URL} \"${CONTEXT_BUILD}\""
            }
        }
        unstable {
            script {
                env.ERROR_MESSAGE = "Tests Suites Failed"
                sh "./pipelines/unittests/build-update.sh ${REPO_NAME} ${COMMIT_FAILED_STATUS} \"Failed Test Suites\" ${ACCESS_TOKEN} ${GIT_COMMIT} ${BUILD_URL} \"${CONTEXT_BUILD}\""
                def rootDir = pwd()
                def emailNotifier = load "${rootDir}/pipelines/unittests/utils/emailNotifier.groovy"

                def failedSuitesMessage = ""
                if (env.FAILED_SUITES && !env.FAILED_SUITES.isEmpty()) {
                    failedSuitesMessage = "Failed Test Suites: ${env.FAILED_SUITES}"
                } else {
                    failedSuitesMessage = "Tests have been detected that have failed in Etendo Core."
                }

                emailNotifier.sendParameterizedEmail(
                    env.ERROR_MESSAGE,
                    '‚ö†Ô∏è',
                    UNSTABLE,
                    failedSuitesMessage
                )
            }
        }
        failure {
            script {
                sh "./pipelines/unittests/build-update.sh ${REPO_NAME} ${COMMIT_FAILED_STATUS} \"${env.ERROR_MESSAGE}\" ${ACCESS_TOKEN} ${GIT_COMMIT} ${BUILD_URL} \"${CONTEXT_BUILD}\""
                echo "--------------- FAILURE ---------------"

                def rootDir = pwd()
                def emailNotifier = load "${rootDir}/pipelines/unittests/utils/emailNotifier.groovy"

                emailNotifier.sendParameterizedEmail(
                    env.ERROR_MESSAGE,
                    'üö´',
                    FAILED,
                    env.ERROR_MESSAGE
                )
            }
        }
    }
}
