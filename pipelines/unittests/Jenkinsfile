pipeline {

  environment { // MARK: Environment variables
    // gradle.properties variables
    CONTEXT_NAME        = 'etendo'
    BBDD_SID            = 'etendo'
    BBDD_PORT           = '5432'
    BBDD_SYSTEMUSER     = 'postgres'
    BBDD_SYSTEMPASS     = 'syspass'
    BBDD_USER           = 'tad'
    BBDD_PASSWORD       = 'tad'
    NEXUS_USER          = credentials('nexus-admin-user')
    NEXUS_PASSWORD      = credentials('nexus-admin-passwd')
    GITHUB_USER         = 'etendobot'
    GITHUB_TOKEN        = credentials('github-read-package-token')
    LANG                = 'en_US.UTF-8'

    ACCESS_TOKEN        = credentials('access_token_github')
    EMAIL_ADDRESS       = credentials('email_builds')

    URL_REPO            = 'https://github.com/etendosoftware/etendo_core'
    URL_REPO_GIT        = 'git@github.com:etendosoftware/etendo_core.git'

    REPO_NAME           = 'etendo_core'

    SUCCESS             = 'SUCCESS'
    FAILED              = 'FAILED'
    UNSTABLE            = 'UNSTABLE'
    ABORTED             = 'ABORTED'

    POSTGRES_VERSION    = '16'

    CONTEXT_BUILD       = 'Unit Tests with Postgres Database'

    COMMIT_INPROGRESS_STATUS = 'pending'
    COMMIT_SUCCESS_STATUS    = 'success'
    COMMIT_FAILED_STATUS     = 'failure'

    TRUE  = 'TRUE'
    FALSE = 'FALSE'

    MAIN_BRANCH = 'main'
  }

  agent { // MARK: Agent
    kubernetes {
      inheritFrom 'jenkins-node-core-unittests'
      defaultContainer 'jnlp'
      yaml """
apiVersion: v1
kind: Pod
metadata:
  name: jenkins-node-core-unittests-0
  namespace: jenkins2025
  labels:
    app.kubernetes.io/name: jenkins-node-core-unittests
spec:
  volumes:
    - name: rsa-keys
      configMap:
        name: rsa-keys
        defaultMode: 384
    - name: docker-sock
      hostPath:
        path: /var/run/docker.sock
        type: ''
  containers:
    - name: compiler
      image: etendo/compiler_jenkins:1.0.7-jdk.17.0.13
      ports:
        - name: ssh
          containerPort: 22
          protocol: TCP
        - name: visualvm
          containerPort: 8000
          protocol: TCP
      resources:
        requests:
          cpu: 3072m
          memory: 4000Mi
        limits:
          cpu: 3072m
          memory: 6000Mi
      volumeMounts:
        - name: rsa-keys
          mountPath: /root/.ssh/
        - name: docker-sock
          mountPath: /var/run/docker.sock
      lifecycle:
        postStart:
          exec:
            command:
              - bash
              - '-c'
              - >-
                chmod a+x /var/run/docker.sock && rm
                /etc/apt/sources.list.d/pgdg.list || echo 0 && apt update && apt
                install -y curl
      terminationMessagePath: /dev/termination-log
      terminationMessagePolicy: File
      imagePullPolicy: IfNotPresent
    - name: postgres
      image: postgres:16
      workingDir: /home/jenkins
      env:
        - name: POSTGRES_PASSWORD
          value: syspass
      resources: {}
      terminationMessagePath: /dev/termination-log
      terminationMessagePolicy: File
      imagePullPolicy: IfNotPresent
  restartPolicy: Always
  terminationGracePeriodSeconds: 30
  dnsPolicy: ClusterFirst
  serviceAccountName: default
  serviceAccount: default
  securityContext: {}
"""
    }
  }

  stages { // MARK: Stages
    stage('Check Pipeline Skip Condition') { // MARK: Check Pipeline Skip Condition
      steps {
        script {
          try {
            echo "---------------------- Setting up Environment Variables ----------------------"
            env.JACOCO_REPORT_EXISTS = FALSE // Indicates whether the Jacoco report exists (TRUE/FALSE)
            env.STATUS_TEST = SUCCESS // Variable to track the status of the test execution.
            env.STATUS_BUILD = FAILED // Variable to track the status of the build.
            env.ERROR_MESSAGE = "Build Failed"
            env.FAILED_SUITES = "" // List to collect failed test suites
            sh "printenv"

            echo "--------------- Checking if pipeline should be skipped ---------------"
            def changedFiles = sh(
              script: "git diff --name-only HEAD~1 HEAD",
              returnStdout: true
            ).trim()

            echo "Files changed in last commit: ${changedFiles}"

            // Check if only JenkinsfileOracle was changed
            def filesList = changedFiles.split('\n')
            def onlyOracleJenkinsfile = filesList.size() == 1 && filesList[0] == "pipelines/unittests/JenkinsfileOracle"

            if (onlyOracleJenkinsfile) {
              echo "‚è≠Ô∏è Only pipelines/unittests/JenkinsfileOracle was changed. Skipping pipeline execution."

              sh "./pipelines/unittests/build-update.sh ${REPO_NAME} ${COMMIT_SUCCESS_STATUS} \"Pipeline skipped\" ${ACCESS_TOKEN} ${GIT_COMMIT} ${BUILD_URL} \"${CONTEXT_BUILD}\""

              echo "‚úÖ Pipeline execution aborted successfully. Commit marked as success."
              currentBuild.result = ABORTED
              return
            } else {
              echo "‚úÖ Pipeline will continue - Changes detected in other files or multiple files changed."
              currentBuild.result = SUCCESS
            }
            
          } catch (Exception e) {
            echo "‚ùå Error in pipeline skip condition check: ${e.getMessage()}"            
            env.ERROR_MESSAGE = "Pipeline Check Failed"
            sh "./pipelines/unittests/build-update.sh ${REPO_NAME} ${COMMIT_FAILED_STATUS} \"${env.ERROR_MESSAGE}\" ${ACCESS_TOKEN} ${GIT_COMMIT} ${BUILD_URL} \"${CONTEXT_BUILD}\""
            currentBuild.result = FAILED
            error("Failed to check pipeline skip condition: ${e.getMessage()}")
          }
        }
      }
    }
    stage ('Stack Configuration') { // MARK: Stack Configuration
      when {
        expression {
          currentBuild.result == SUCCESS
        }
      }
      steps {
        container('compiler') {
          script {
            try {
              echo "--------------- Getting Backport Branch Information ---------------"
              def pattern = /-Y\d{2}$/
              env.CONTAINS_Y_SUFFIX = (env.GIT_BRANCH ==~ pattern) ? TRUE : FALSE
              env.FROM_BACKPORT = FALSE
              env.FROM_PRERELEASE = FALSE
              def yearBackportBranch = (env.BACKPORT_BRANCH =~ /release\/(\d{2})\./)?.find() ? (env.BACKPORT_BRANCH =~ /release\/(\d{2})\./)[0][1] : null
              def yearPrereleaseBranch = (env.PRERELEASE_BRANCH =~ /prerelease\/(\d{2})\./)?.find() ? (env.PRERELEASE_BRANCH =~ /prerelease\/(\d{2})\./)[0][1] : null
              
              // Extract backport branch information without using Matcher object
              if (env.CONTAINS_Y_SUFFIX == TRUE) {
                def yearCommitBranch = (env.GIT_BRANCH =~ /-Y(\d{2})/)?.find() ? (env.GIT_BRANCH =~ /-Y(\d{2})/)[0][1] : null
                if (yearCommitBranch && yearBackportBranch && yearPrereleaseBranch) {
                  env.FROM_BACKPORT = (yearCommitBranch == yearBackportBranch) ? env.TRUE : env.FALSE
                  env.FROM_PRERELEASE = (yearCommitBranch == yearPrereleaseBranch) ? env.TRUE : env.FALSE
                }
              } else if (GIT_BRANCH.startsWith("release")) {
                echo '-------------------------- Backport Branch Detected --------------------------'
                env.FROM_BACKPORT = env.TRUE
              } else if (GIT_BRANCH.startsWith("prerelease")) {
                echo '-------------------------- Prerelease Branch Detected --------------------------'
                env.FROM_PRERELEASE = env.TRUE
              }
              echo "---------------- Stack Configuration ----------------"
              def rootDir = pwd()
              def stackConfig = load "${rootDir}/pipelines/unittests/utils/stackConfig.groovy"

              def stackConfiguration = stackConfig.resolveStackConfiguration(env.FROM_BACKPORT, env.FROM_PRERELEASE)
              
              env.JAVA_HOME = stackConfiguration.javaHome
              env.TOMCAT_URL = stackConfiguration.tomcatUrl
              env.STACK_TYPE = stackConfiguration.stackType

              echo "Stack Type: ${env.STACK_TYPE}"
              echo "Tomcat URL: ${env.TOMCAT_URL}"
              echo "Java Home: ${env.JAVA_HOME}"

              sh "wget -O apache-tomcat.tar.gz ${TOMCAT_URL}"
              sh "tar -xvf apache-tomcat.tar.gz -C ${WORKSPACE}"

              env.TOMCAT_FOLDER = stackConfig.getTomcatFolder()
              env.CATALINA_HOME = "${WORKSPACE}/${TOMCAT_FOLDER}"
              env.CATALINA_BASE = "${WORKSPACE}/${TOMCAT_FOLDER}"

              env.STACK_INFO = stackConfig.generateStackMessage()
              echo "__________________________________________________"
              echo "${env.STACK_INFO}"
              echo "__________________________________________________"
            } catch (Exception e) {
              env.ERROR_MESSAGE = "Stack Configuration Failed"
              echo "--------------- ${env.ERROR_MESSAGE} ---------------"
              echo "Exception occurred: " + e.toString()
              currentBuild.result = FAILED
              error(env.ERROR_MESSAGE)
            }
          }
        }
      }
    }
    stage ('Build Environment') { // MARK: Build Environment
      when {
        expression {
          currentBuild.result == SUCCESS
        }
      }
      steps {
        container('compiler') {
          script {
            try {
              sh "./pipelines/unittests/build-update.sh ${REPO_NAME} ${COMMIT_INPROGRESS_STATUS} \"Starting Build\" ${ACCESS_TOKEN} ${GIT_COMMIT} ${BUILD_URL} \"${CONTEXT_BUILD}\""

              withCredentials([sshUserPrivateKey(credentialsId: 'my-credentials', keyFileVariable: 'keyfile')]) {
                sh "GIT_SSH_COMMAND=\"ssh -i ${keyfile} -o \"UserKnownHostsFile=/dev/null\" -o \"StrictHostKeyChecking=no\"\" git clone ${URL_REPO_GIT} ${REPO_NAME}"
              }

              env.WORKDIR_ETENDO = "${pwd()}"

              dir(REPO_NAME) {
                echo "---------------- Getting Commit Information ----------------"
                sh "git checkout ${GIT_COMMIT}"
                def rootDir = pwd()
                def infoCommit = load "${rootDir}/pipelines/unittests/utils/infoCommit.groovy"
                env.COMMIT_INFO = infoCommit.generateCommitInfo(env.URL_REPO)

                echo "--------------- Getting Sonar projectKey of ${REPO_NAME} ---------------"
                def propertiesContent = readFile "sonar-project.properties"
                def lines = propertiesContent.split('\n')
                def projectKey = ""
                lines.each { line ->
                  if (line.startsWith('sonar.projectKey=')) {
                    projectKey = line.split('=')[1]
                  }
                }
                env.PROJECT_KEY = "${projectKey}"


                echo "--------------- Configure gradle.properties ---------------"
                sh """
                echo "\n
                context.name=${CONTEXT_NAME}
                bbdd.sid=${BBDD_SID}
                bbdd.port=${BBDD_PORT}
                bbdd.systemUser=${BBDD_SYSTEMUSER}
                bbdd.systemPassword=${BBDD_SYSTEMPASS}
                bbdd.user=${BBDD_USER}
                bbdd.password=${BBDD_PASSWORD}
                nexusUser=${NEXUS_USER}
                nexusPassword=${NEXUS_PASSWORD}
                githubUser=${GITHUB_USER}
                githubToken=${GITHUB_TOKEN}
                allow.root=true
                org.gradle.jvmargs=-Dfile.encoding=UTF-8
                org.gradle.daemon=false
                org.gradle.jvmargs=-XX:MaxHeapSize=1g -Xmx5g
                java.version=11" > gradle.properties
                """

                sh """
                ./gradlew prepareConfig --info
                ./gradlew setup --info
                ./gradlew expandModules --info
                ./gradlew install --info
                ./gradlew update.database  --info
                ./gradlew smartbuild --info
                ./gradlew --stop
                """
              }
              sh "${WORKSPACE}/${TOMCAT_FOLDER}/bin/catalina.sh start"
              sleep(time: 1, unit: 'MINUTES')
              currentBuild.result = SUCCESS
              env.STATUS_BUILD = SUCCESS
              echo "--------------- Build Environment Successful ---------------"
            } catch (Exception e) {
              env.ERROR_MESSAGE = "Build Environment Failed"
              echo "--------------- ${env.ERROR_MESSAGE} ---------------"
              echo "Exception occurred: " + e.toString()
              currentBuild.result = FAILED
              error(env.ERROR_MESSAGE)
              env.STATUS_BUILD = FAILED
              env.STATUS_TEST = FAILED
            }
          }
        }
      }
    }
// __________________________________________________________________________________________
// ------------------------------ WEB SERVICES TESTS ----------------------------------------
    stage ('Web Service Test Suite') { // MARK: Web Service Test Suite
      when {
        expression {
          env.STATUS_BUILD == SUCCESS
        }
      }
      steps {
        sh "./pipelines/unittests/build-update.sh ${REPO_NAME} ${COMMIT_INPROGRESS_STATUS} \"Running Test Suites\" ${ACCESS_TOKEN} ${GIT_COMMIT} ${BUILD_URL} \"${CONTEXT_BUILD}\""
        container('compiler') {
          script {
            dir(REPO_NAME) {
              def suiteName = "org.openbravo.test.WebserviceTestSuite"
              try {
                echo "--------------- Running ${suiteName} ---------------"
                sh "./gradlew test --tests ${suiteName} --info"
                sh "mv build/jacoco/test.exec build/jacoco/test0.exec"
                echo "--------------- ${suiteName} Successful ---------------"
                currentBuild.result = SUCCESS
              } catch (Exception e) {
                env.ERROR_MESSAGE = "${suiteName} Failed"
                echo "--------------- ${env.ERROR_MESSAGE} ---------------"
                echo 'Exception occurred: ' + e.toString()
                currentBuild.result = UNSTABLE
                unstable(env.ERROR_MESSAGE)
                env.STATUS_TEST = FAILED

                def currentFailed = env.FAILED_SUITES ?: ""
                env.FAILED_SUITES = currentFailed.isEmpty() ? "${suiteName}" : "${currentFailed}, ${suiteName}"
              } finally {
                if (fileExists("build/reports/tests/test/")) {
                  publishHTML([
                    allowMissing: true,
                    alwaysLinkToLastBuild: false,
                    keepAll: true,
                    reportDir: 'build/reports/tests/test',
                    reportFiles: '*.html',
                    reportName: 'WEBSERVICES TESTS REPORT',
                    reportTitles: ''
                  ])
                  sh "rm -rf build/reports/tests/test"
                } else {
                 echo "Report directory of Webservices tests does not exist. Skipping HTML report publishing."
                }
                sh "${WORKSPACE}/${TOMCAT_FOLDER}/bin/catalina.sh stop"
                sh "./gradlew --stop"
              }
            }
          }
        }
      }
    }
// __________________________________________________________________________________________
// ------------------------------ com.smf.* TESTS ------------------------------------------
    stage ('Core Test Suite') { // MARK: CoreTestSuite Test Suite
      when {
        expression {
          env.STATUS_BUILD == SUCCESS
        }
      }
      steps {
        container('compiler') {
          script {
            dir(REPO_NAME) {
              def suiteName = "com.smf.test.CoreTestSuite"
              try {
                echo "--------------- Running ${suiteName} ---------------"
                sh "./gradlew test --tests ${suiteName} --info"
                sh "mv build/jacoco/test.exec build/jacoco/test1.exec"
                echo "--------------- ${suiteName} Successful ---------------"
                currentBuild.result = SUCCESS
              } catch (Exception e) {
                env.ERROR_MESSAGE = "${suiteName} Failed"
                echo "--------------- ${env.ERROR_MESSAGE} ---------------"
                echo 'Exception occurred: ' + e.toString()
                currentBuild.result = UNSTABLE
                unstable(env.ERROR_MESSAGE)
                env.STATUS_TEST = FAILED

                def currentFailed = env.FAILED_SUITES ?: ""
                env.FAILED_SUITES = currentFailed.isEmpty() ? "${suiteName}" : "${currentFailed}, ${suiteName}"
              } finally {
                if (fileExists("build/reports/tests/test/")) {
                  publishHTML([
                    allowMissing: false,
                    alwaysLinkToLastBuild: false,
                    keepAll: true,
                    reportDir: 'build/reports/tests/test',
                    reportFiles: '*.html',
                    reportName: 'com.smf.* TESTS REPORT',
                    reportTitles: ''
                  ])
                  sh "rm -rf build/reports/tests/test"
                } else {
                  echo "Report directory of com.smf.* tests does not exist. Skipping HTML report publishing."
                }

              }
            }
          }
        }
      }
    }
// __________________________________________________________________________________________
// ------------------------------- STANDALONE TESTS -----------------------------------------
    stage ('Standalone Test Suite') { // MARK: Standalone Test Suite
      when {
        expression {
          env.STATUS_BUILD == SUCCESS
        }
      }
      steps {
        container('compiler') {
          script {
            dir(REPO_NAME) {
              def suiteName = "org.openbravo.test.StandaloneTestSuite"
              try {
                echo "--------------- Running ${suiteName} ---------------"
                sh "./gradlew test --tests ${suiteName} --info"
                sh "mv build/jacoco/test.exec build/jacoco/test2.exec"
                echo "--------------- ${suiteName} Successful ---------------"
                currentBuild.result = SUCCESS
              } catch (Exception e) {
                env.ERROR_MESSAGE = "${suiteName} Failed"
                echo "--------------- ${env.ERROR_MESSAGE} ---------------"
                echo 'Exception occurred: ' + e.toString()
                currentBuild.result = UNSTABLE
                unstable(env.ERROR_MESSAGE)
                env.STATUS_TEST = FAILED
                
                def currentFailed = env.FAILED_SUITES ?: ""
                env.FAILED_SUITES = currentFailed.isEmpty() ? "${suiteName}" : "${currentFailed}, ${suiteName}"
              } finally {
                if (fileExists("build/reports/tests/test/")) {
                  publishHTML([
                    allowMissing: true,
                    alwaysLinkToLastBuild: false,
                    keepAll: true,
                    reportDir: 'build/reports/tests/test',
                    reportFiles: '*.html',
                    reportName: 'STANDALONE TESTS REPORT',
                    reportTitles: ''
                  ])
                  sh "rm -rf build/reports/tests/test"
                } else {
                  echo "Report directory of Standalone tests does not exist. Skipping HTML report publishing."
                }
              }
            }
          }
        }
      }
    }
// __________________________________________________________________________________________
// ----------------------------------- com.etendoerp.* TESTS --------------------------------
    stage ('com.etendoerp.* Tests') { // MARK: com.etendoerp.* Test
      when {
        expression {
          env.STATUS_BUILD == SUCCESS
        }
      }
      steps {
        container('compiler') {
          script {
            dir(REPO_NAME) {
              def suiteName = "com.etendoerp.*"
              try {
                echo "--------------- Running ${suiteName} Tests ---------------"
                sh "./gradlew test --tests \"com.etendoerp.*\" --info"
                sh "mv build/jacoco/test.exec build/jacoco/test3.exec"
                sh "./gradlew --stop"
                echo "--------------- ${suiteName} Tests Successful ---------------"
                currentBuild.result = SUCCESS
              } catch (Exception e) {
                env.ERROR_MESSAGE = "${suiteName} Tests Failed"
                echo "--------------- ${env.ERROR_MESSAGE} ---------------"
                echo 'Exception occurred: ' + e.toString()
                currentBuild.result = UNSTABLE
                unstable(env.ERROR_MESSAGE)
                env.STATUS_TEST = FAILED

                def currentFailed = env.FAILED_SUITES ?: ""
                env.FAILED_SUITES = currentFailed.isEmpty() ? "${suiteName} Tests" : "${currentFailed}, ${suiteName} Tests"
              } finally {
                if (fileExists('build/spock-reports/')) {
                  publishHTML([
                    allowMissing: true,
                    alwaysLinkToLastBuild: false,
                    keepAll: true,
                    reportDir: 'build/spock-reports/',
                    reportFiles: '*.html',
                    reportName: 'com.etendoerp.* SPOCK TESTS REPORT',
                    reportTitles: ''
                  ])
                  sh "rm -rf build/spock-reports"
                } else {
                  echo "Spock report directory of com.etendoerp.* tests does not exist. Skipping HTML report publishing."
                }

                if (fileExists('build/reports/tests/test/')) {
                  publishHTML([
                    allowMissing: true,
                    alwaysLinkToLastBuild: false,
                    keepAll: true,
                    reportDir: 'build/reports/tests/test',
                    reportFiles: '*.html',
                    reportName: 'com.etendoerp.* TESTS REPORT',
                    reportTitles: ''
                  ])
                  sh "rm -rf build/reports/tests/test"
                } else {
                  echo "Report directory of com.etendoerp.* tests does not exist. Skipping HTML report publishing."
                }
              }
            }
          }
        }
      }
    }
// __________________________________________________________________________________________
// ----------------------------------- JACOCO REPORT ----------------------------------------
    stage('Generate Coverage Report') { // MARK: Generate Coverage Report
      when {
        expression {
          env.STATUS_TEST == SUCCESS && env.STATUS_BUILD == SUCCESS
        }
      }
      steps {
        container("compiler") {
          script {
            sh "./pipelines/unittests/build-update.sh ${REPO_NAME} ${COMMIT_INPROGRESS_STATUS} \"Generating JaCoCo report\" ${ACCESS_TOKEN} ${GIT_COMMIT} ${BUILD_URL} \"${CONTEXT_BUILD}\""
            echo "---------------------- Run jacocoRootReport ----------------------"
            sh """
            su etendo
            cd ${REPO_NAME}
            ./gradlew jacocoRootReport --info
            """

            env.JACOCO_REPORT = "build/reports/jacoco/jacocoRootReport/jacocoRootReport.xml"

            if (fileExists("${REPO_NAME}/${JACOCO_REPORT}")) {
              echo "---------------------- Jacoco Report Found ----------------------"
              env.JACOCO_REPORT_EXISTS = TRUE
            }
          }
        }
      }
    }
// __________________________________________________________________________________________
// ----------------------------------- SONARQUBE ANALYSIS -----------------------------------
    stage('SonarQube Analysis') { // MARK: SonarQube Analysis
      when {
        expression {
          JACOCO_REPORT_EXISTS == TRUE
        }
      }
      steps {
        container('compiler') {
          script {
            try {
              sh "./pipelines/unittests/build-update.sh ${REPO_NAME} ${COMMIT_INPROGRESS_STATUS} \"Running SonarQube Analysis\" ${ACCESS_TOKEN} ${GIT_COMMIT} ${BUILD_URL} \"${CONTEXT_BUILD}\""

              def modulesCoreExclusions = [
                "com.smf.userinterface.skin.legacy",
                "org.openbravo.client.widgets",
                "org.openbravo.client.htmlwidget",
                "com.smf.smartclient.debugtools",
                "org.openbravo.client.myob",
                "org.openbravo.userinterface.smartclient",
                "com.smf.smartclient.boostedui",
                "com.etendoerp.client.application"
              ]

              def sourceExclusions = modulesCoreExclusions.collect { "modules_core/${it}/**" }.join(',')

              echo "---------------------- Add deprecated classes to sourceExclusions list ----------------------"
              def deprecatedFiles = sh(
                  script: '''
                    cd ${REPO_NAME}
                    find . -name "*.java" -exec grep -l '@Deprecated' {} + | while read file; do
                      if grep -A1 '@Deprecated' "$file" | grep -q 'public class'; then
                        echo "$file"
                      fi
                    done
                  ''',
                  returnStdout: true
              ).trim().split('\n')

              def deprecatedExclusions = deprecatedFiles.collect { it.replaceFirst("^\\./", "") }.join(',')
              sourceExclusions = "${sourceExclusions},${deprecatedExclusions}"

              echo "Sources to exclusions: ${sourceExclusions}"
              def modules_src_dirs = sh(script: "cd ${REPO_NAME}/modules_core && find . -type d -name 'src' | grep -v 'src-util' | sed 's|./|modules_core/|' | tr '\n' ','", returnStdout: true).trim()
              echo "Modules with src directories: ${modules_src_dirs}"

              echo "--------------- Installing SonarQube ---------------"
              env.JAVA_HOME = "/usr/lib/jvm/jdk-17.0.13"
              sh """
                apt-get update && apt-get install -y wget unzip
                wget https://binaries.sonarsource.com/Distribution/sonar-scanner-cli/sonar-scanner-cli-${SONAR_VERSION}-linux.zip
                unzip sonar-scanner-cli-${SONAR_VERSION}-linux.zip
                export PATH=\$PATH:\${WORKSPACE}/sonar-scanner-${SONAR_VERSION}-linux/bin
              """

              echo '-------------------------- Executing SonarQube Analysis --------------------------'
              sh """
                cd ${REPO_NAME}
                ${WORKSPACE}/sonar-scanner-${SONAR_VERSION}-linux/bin/sonar-scanner -X \
                    -Dsonar.projectKey=${env.PROJECT_KEY} \
                    -Dsonar.sources=${modules_src_dirs}src \
                    -Dsonar.host.url=${SONAR_SERVER} \
                    -Dsonar.token=${SONAR_TOKEN} \
                    -Dsonar.branch.name=${GIT_BRANCH} \
                    -Dsonar.projectVersion=${GIT_COMMIT} \
                    -Dsonar.java.coveragePlugin=jacoco \
                    -Dsonar.coverage.jacoco.xmlReportPaths=${JACOCO_REPORT} \
                    -Dsonar.inclusions=**/*.java \
                    -Dsonar.exclusions=${sourceExclusions}
              """
              echo "---------------------- Getting SonarQube Report URL ----------------------"
              def branchName = URLEncoder.encode(GIT_BRANCH, 'UTF-8')
              def projectUrl = "${SONAR_SERVER}/dashboard?id=${PROJECT_KEY}&branch=${branchName}"
              env.PROJECT_URL = "${projectUrl}"
              echo "Sonar Project URL: ${PROJECT_URL}"
              echo "--------------- Execution SonarQube Succesful ---------------"
              currentBuild.result = SUCCESS
            } catch (Exception e) {
              env.ERROR_MESSAGE = "Execution SonarQube Failed"
              echo "--------------- ${env.ERROR_MESSAGE} ---------------"
              echo "Exception occurred: " + e.toString()
              currentBuild.result = FAILED
              error(env.ERROR_MESSAGE)
            }
          }
        }
      }
    }

// __________________________________________________________________________________________
// ------------------------------ COMPARE COVERAGE RESULTS ----------------------------------
    stage('Compare Coverage Results') { // MARK: - Compare Coverage Results
      when {
        expression {
          currentBuild.result == SUCCESS && env.JACOCO_REPORT_EXISTS == TRUE && !(env.GIT_BRANCH == env.MAIN_BRANCH || env.GIT_BRANCH.startsWith("release/"))
        }
      }
      steps {
        script {
          try {
            sh "./pipelines/unittests/build-update.sh ${REPO_NAME} ${COMMIT_INPROGRESS_STATUS} \"Comparing Coverage Results\" ${ACCESS_TOKEN} ${GIT_COMMIT} ${BUILD_URL} \"${CONTEXT_BUILD}\""
            def branchCompare = env.MAIN_BRANCH
            env.COMPARE_COVERAGE_STATUS = SUCCESS
            if (env.FROM_BACKPORT == TRUE) {
              branchCompare = env.BACKPORT_BRANCH
            }
            echo "-------------------------- Comparing Coverage with ${branchCompare} Branch --------------------------"

            def rootDir = pwd()
            def sonarUtils = load "${rootDir}/pipelines/unittests/utils/sonarUtils.groovy"

            // Only check commit on PR branches
            def checkCommitCurrent = GIT_BRANCH.startsWith('feature/') || 
                                     GIT_BRANCH.startsWith('hotfix/') || 
                                     GIT_BRANCH.startsWith('epic/')
            echo "Check commit for current branch (${GIT_BRANCH}): ${checkCommitCurrent}"
            def coverageCurrent = sonarUtils.getCoverageWithRetry(
              GIT_BRANCH,
              checkCommitCurrent,
              env.PROJECT_KEY,
              SONAR_TOKEN,
              SONAR_SERVER,
              env.GIT_COMMIT
            )
            def coverageOriginBranch = sonarUtils.getCoverageWithRetry(
              branchCompare,
              false,
              env.PROJECT_KEY,
              SONAR_TOKEN,
              SONAR_SERVER,
              null
            )

            echo "Current branch (${env.GIT_COMMIT}) coverage: ${coverageCurrent}%"
            echo "${branchCompare} branch coverage: ${coverageOriginBranch}%"
            if (coverageCurrent < coverageOriginBranch) {
              env.ERROR_MESSAGE = "Coverage (${coverageCurrent}%) is lower than ${branchCompare} branch (${coverageOriginBranch}%)"
              echo "-------------------------- ${env.ERROR_MESSAGE} --------------------------"
              currentBuild.result = UNSTABLE
              env.COMPARE_COVERAGE_STATUS = FAILED
              unstable(env.ERROR_MESSAGE)
            } else {
              echo "-------------------------- Coverage is OK --------------------------"
              currentBuild.result = SUCCESS
            }
          } catch (Exception e) {
            echo "Exception occurred: " + e.toString()
            env.ERROR_MESSAGE = "Comparing Coverage Results Failed"
            echo "-------------------------- ${env.ERROR_MESSAGE} --------------------------"
            currentBuild.result = UNSTABLE
            error(env.ERROR_MESSAGE)
          }
        }
      }
    }

// __________________________________________________________________________________________
// ----------------------------------- DEPLOY SNAPSHOT --------------------------------------
    stage('Run Deploy Snapshot') { // MARK: Run Deploy Snapshot
      when {
        allOf {
          anyOf {
            branch 'develop'
          }
          expression {
              env.STATUS_TEST == SUCCESS && env.STATUS_BUILD == SUCCESS && env.JACOCO_REPORT_EXISTS == TRUE && env.COMPARE_COVERAGE_STATUS == SUCCESS
          }
        }
      }
      steps {
        container('compiler') {
          script {
            try {
              sh "./pipelines/unittests/build-update.sh ${REPO_NAME} ${COMMIT_INPROGRESS_STATUS} \"Deploying Snapshot\" ${ACCESS_TOKEN} ${GIT_COMMIT} ${BUILD_URL} \"${CONTEXT_BUILD}\""
              echo "--------------- Running Deploy Snapshot ---------------"
              dir(REPO_NAME) {
                withCredentials([sshUserPrivateKey(credentialsId: 'my-credentials', keyFileVariable: 'keyfile')]) {
                  withCredentials([usernamePassword(credentialsId: "etendo_bot_credentials", passwordVariable: 'GIT_PASSWORD', usernameVariable: 'GIT_USERNAME')]) {
                      sh """
                      git config user.name "${GIT_USERNAME}"
                      git config user.email "${GIT_USERNAME}"
                      """
                      sh "echo version.ts=\$(date +\"%s\") > version.properties"
                      sh "./gradlew publishCoreJar --info"
                      sh "git tag \"v\$(grep version.ts version.properties|cut -c 11-)\" -m \"Release SNAPSHOT \$(grep version.tag version.properties|cut -c 13-)\""
                      sh "GIT_SSH_COMMAND=\"ssh -i ${keyfile} -o \"UserKnownHostsFile=/dev/null\" -o \"StrictHostKeyChecking=no\"\" git push ${GIT_URL} \"v\$(grep version.ts version.properties|cut -c 11-)\""
                  }
                }
              }
            } catch (Exception e) {
              env.ERROR_MESSAGE = "Deploy Snapshot Failed"
              echo "--------------- ${env.ERROR_MESSAGE} ---------------"
              echo "Exception occurred: " + e.toString()
              currentBuild.result = FAILED
              error(env.ERROR_MESSAGE)
            }
          }
        }
      }
    }
  }
  post {  // MARK: Post Actions
    success {
        script {
            sh "./pipelines/unittests/build-update.sh ${REPO_NAME} ${COMMIT_SUCCESS_STATUS} \"Successful Test Suites\" ${ACCESS_TOKEN} ${GIT_COMMIT} ${BUILD_URL} \"${CONTEXT_BUILD}\""
            echo "--------------- DONE ---------------"
        }
    }
    unstable {
      script {
        def rootDir = pwd()
        def emailNotifier = load "${rootDir}/pipelines/unittests/utils/emailNotifier.groovy"
        
        echo "--------------- UNSTABLE ---------------"
        def mailSubject = ""
        def bodyMessageError = ""
        def icon = "‚ùó"
        
        if (env.STATUS_TEST == FAILED) {
          mailSubject = "Tests Failed"
          if (env.FAILED_SUITES && !env.FAILED_SUITES.isEmpty()) {
              bodyMessageError = "Failed Test Suites: ${env.FAILED_SUITES}"
          } else {
              bodyMessageError = "Tests have been detected that have failed in Etendo Core."
          }
          icon = "‚ö†Ô∏è"
        } else if (env.COMPARE_COVERAGE_STATUS == FAILED) {
          mailSubject = "Coverage Decreased"
          bodyMessageError = env.ERROR_MESSAGE ?: "Coverage has decreased compared to the base branch."
          icon = "üìâ"
        } else {
          mailSubject = "Build Unstable"
          bodyMessageError = "The build is unstable. Please check the logs for more information."
          icon = "‚ùó"
        }
        sh "./pipelines/unittests/build-update.sh ${REPO_NAME} ${COMMIT_FAILED_STATUS} \"${mailSubject}\" ${ACCESS_TOKEN} ${GIT_COMMIT} ${BUILD_URL} \"${CONTEXT_BUILD}\""

        emailNotifier.sendParameterizedEmail(
          mailSubject,
          icon,
          UNSTABLE,
          bodyMessageError
        )
      }
    }
    failure {
      script {
        sh "./pipelines/unittests/build-update.sh ${REPO_NAME} ${COMMIT_FAILED_STATUS} \"${ERROR_MESSAGE}\" ${ACCESS_TOKEN} ${GIT_COMMIT} ${BUILD_URL} \"${CONTEXT_BUILD}\""
        echo "--------------- FAILURE ---------------"
        
        def rootDir = pwd()
        def emailNotifier = load "${rootDir}/pipelines/unittests/utils/emailNotifier.groovy"

        emailNotifier.sendParameterizedEmail(
          env.ERROR_MESSAGE,
          '‚õî',
          FAILED,
          env.ERROR_MESSAGE
        )
      }
    }
  }
}
